TODO:

- 2.3 Prerequisites for effective testing 	- WRITE!
- 3. GUI testing 							- review and polish
- 4.3 Drawbacks of unit testing 			- WRITE !
- 4.4 Success factors of unit testing 		- WRITE!
- 5 Legacy code and refactoring 			- review and polish
- 6.3.1 Time 								- review and polish						- 6.3.3 Test runtime 						- review and polish
- 6.3.5 Defects								- review and polish
- 6.4.2 NUnit								- WRITE!

- something about how slow it was to use the service object list?
- extending the tests further? reuse gui but not unit? different mileages in odometer
- there are fewer components in case 1 but it takes longer to run and implement
- usability and number of components?
- test run time - varians?

Implementation
- test cases for each thingy

Results
- 8.2.2 Code Changes 						- WRITE!
- 8.3 Test runtime 							- review and polish
- 8.7.2 Scope 								- WRITE!
- 8.7.3 GUI tests							- review and polish
- 8.7.4 Unit tests							- review and polish
- 9 Further work							- WRITE!
- 10 Conclusion 							- WRITE!								

DONE:
- 8.6 Training 								- WRITE!
- 8.7.1 Test environments					- review and polish
- 8.5 Defects 								- review and polish
- 8.2.3 Test Data							- review and polish
- who wins which section?
- 8.1 Time									- review and polish
- 8.2.1 GUI changes							- review and polish
- 8.8 Risks 								- WRITE!

----------------------------------------------------------------------
Who wins?

TIME
Case 1 GUI = 4 unit
Case 2 GUI = unit

CHANGES
uncomparable

TEST DATA
GUI requires more effort

RUNTIME
unit > GUI

CODE COMPLEXITY
uncomparable

DEFECTS
uncomparable

TRAINING
GUI > unit
